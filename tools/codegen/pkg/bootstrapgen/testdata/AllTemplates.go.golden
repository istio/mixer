// Copyright 2017 Istio Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// THIS FILE IS AUTOMATICALLY GENERATED.

package tmp

import (
	"context"
	"fmt"

	"github.com/golang/protobuf/proto"

	"istio.io/api/mixer/v1/config/descriptor"
	"istio.io/mixer/pkg/adapter"
	adptTmpl "istio.io/mixer/pkg/adapter/template"
	"istio.io/mixer/pkg/attribute"
	"istio.io/mixer/pkg/expr"
	"istio.io/mixer/pkg/template"

	"istio.io/mixer/template/list"

	"istio.io/mixer/template/quota"

	"istio.io/mixer/template/log"

	"istio.io/mixer/template/metric"
)

var (
	SupportedTmplInfo = map[string]template.Info{

		istio_mixer_template_list.TemplateName: {
			CtrCfg:             &istio_mixer_template_list.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_CHECK,
			BldrInterfaceName:  "istio.io/mixer/template/list.HandlerBuilder",
			HndlrInterfaceName: "istio.io/mixer/template/list.Handler",
			SupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(istio_mixer_template_list.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(istio_mixer_template_list.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {
				var err error = nil
				cpb := cp.(*istio_mixer_template_list.InstanceParam)
				infrdType := &istio_mixer_template_list.Type{}

				if cpb.Value == "" {
					return nil, fmt.Errorf("expression for field Value cannot be empty")
				}
				if infrdType.Value, err = tEvalFn(cpb.Value); err != nil {
					return nil, err
				}

				infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
				for k, v := range cpb.Dimensions {
					if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
						return nil, err
					}
				}

				if cpb.Int64Primitive == "" {
					return nil, fmt.Errorf("expression for field Int64Primitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.Int64Primitive); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field Int64Primitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field Int64Primitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
				}

				if cpb.BoolPrimitive == "" {
					return nil, fmt.Errorf("expression for field BoolPrimitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.BoolPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.BOOL {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field BoolPrimitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field BoolPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.BOOL)
				}

				if cpb.DoublePrimitive == "" {
					return nil, fmt.Errorf("expression for field DoublePrimitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.DoublePrimitive); e != nil || t != istio_mixer_v1_config_descriptor.DOUBLE {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field DoublePrimitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field DoublePrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.DOUBLE)
				}

				if cpb.StringPrimitive == "" {
					return nil, fmt.Errorf("expression for field StringPrimitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.StringPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field StringPrimitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field StringPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				if cpb.AnotherValueType == "" {
					return nil, fmt.Errorf("expression for field AnotherValueType cannot be empty")
				}
				if infrdType.AnotherValueType, err = tEvalFn(cpb.AnotherValueType); err != nil {
					return nil, err
				}

				for _, v := range cpb.DimensionsFixedInt64ValueDType {
					if t, e := tEvalFn(v); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field DimensionsFixedInt64ValueDType: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field DimensionsFixedInt64ValueDType: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
					}
				}

				if cpb.CheckExpression == "" {
					return nil, fmt.Errorf("expression for field CheckExpression cannot be empty")
				}
				if t, e := tEvalFn(cpb.CheckExpression); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field CheckExpression: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field CheckExpression: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				_ = cpb
				return infrdType, err
			},
			ConfigureType: func(types map[string]proto.Message, builder *adapter.HandlerBuilder) error {
				// Mixer framework should have ensured the type safety.
				castedBuilder := (*builder).(istio_mixer_template_list.HandlerBuilder)
				castedTypes := make(map[string]*istio_mixer_template_list.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*istio_mixer_template_list.Type)
					castedTypes[k] = v1
				}
				return castedBuilder.ConfigureListHandler(castedTypes)
			},
			Evaluate: func(instName string, inst proto.Message, attrs attribute.Bag, mapper expr.Evaluator) (interface{}, error) {
				castedInst := inst.(*istio_mixer_template_list.InstanceParam)

				Value, err := mapper.Eval(castedInst.Value, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval Value for instance '%s': %v", instName, err)
				}

				Dimensions, err := template.EvalAll(castedInst.Dimensions, attrs, mapper)

				if err != nil {
					return nil, fmt.Errorf("failed to eval Dimensions for instance '%s': %v", instName, err)
				}

				Int64Primitive, err := mapper.Eval(castedInst.Int64Primitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval Int64Primitive for instance '%s': %v", instName, err)
				}

				BoolPrimitive, err := mapper.Eval(castedInst.BoolPrimitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval BoolPrimitive for instance '%s': %v", instName, err)
				}

				DoublePrimitive, err := mapper.Eval(castedInst.DoublePrimitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval DoublePrimitive for instance '%s': %v", instName, err)
				}

				StringPrimitive, err := mapper.Eval(castedInst.StringPrimitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval StringPrimitive for instance '%s': %v", instName, err)
				}

				AnotherValueType, err := mapper.Eval(castedInst.AnotherValueType, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval AnotherValueType for instance '%s': %v", instName, err)
				}

				DimensionsFixedInt64ValueDType, err := template.EvalAll(castedInst.DimensionsFixedInt64ValueDType, attrs, mapper)

				if err != nil {
					return nil, fmt.Errorf("failed to eval DimensionsFixedInt64ValueDType for instance '%s': %v", instName, err)
				}

				CheckExpression, err := mapper.Eval(castedInst.CheckExpression, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval CheckExpression for instance '%s': %v", instName, err)
				}

				_ = castedInst

				return &istio_mixer_template_list.Instance{
					Name: instName,

					Value: Value,

					Dimensions: Dimensions,

					Int64Primitive: Int64Primitive.(int64),

					BoolPrimitive: BoolPrimitive.(bool),

					DoublePrimitive: DoublePrimitive.(float64),

					StringPrimitive: StringPrimitive.(string),

					AnotherValueType: AnotherValueType,

					DimensionsFixedInt64ValueDType: func(m map[string]interface{}) map[string]int64 {
						res := make(map[string]int64, len(m))
						for k, v := range m {
							res[k] = v.(int64)
						}
						return res
					}(DimensionsFixedInt64ValueDType),

					CheckExpression: CheckExpression.(string),
				}, nil
			},

			DispatchCheck: func(ctx context.Context, insts interface{}, handler adapter.Handler) (adapter.CheckResult, error) {
				return handler.(istio_mixer_template_list.Handler).HandleList(ctx, insts.(*istio_mixer_template_list.Instance))
			},
			DispatchReport: nil,
			DispatchQuota:  nil,
		},

		istio_mixer_template_quota.TemplateName: {
			CtrCfg:             &istio_mixer_template_quota.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  "istio.io/mixer/template/quota.HandlerBuilder",
			HndlrInterfaceName: "istio.io/mixer/template/quota.Handler",
			SupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(istio_mixer_template_quota.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(istio_mixer_template_quota.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {
				var err error = nil
				cpb := cp.(*istio_mixer_template_quota.InstanceParam)
				infrdType := &istio_mixer_template_quota.Type{}

				if cpb.Value == "" {
					return nil, fmt.Errorf("expression for field Value cannot be empty")
				}
				if infrdType.Value, err = tEvalFn(cpb.Value); err != nil {
					return nil, err
				}

				infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
				for k, v := range cpb.Dimensions {
					if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
						return nil, err
					}
				}

				if cpb.Int64Primitive == "" {
					return nil, fmt.Errorf("expression for field Int64Primitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.Int64Primitive); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field Int64Primitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field Int64Primitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
				}

				if cpb.BoolPrimitive == "" {
					return nil, fmt.Errorf("expression for field BoolPrimitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.BoolPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.BOOL {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field BoolPrimitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field BoolPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.BOOL)
				}

				if cpb.DoublePrimitive == "" {
					return nil, fmt.Errorf("expression for field DoublePrimitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.DoublePrimitive); e != nil || t != istio_mixer_v1_config_descriptor.DOUBLE {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field DoublePrimitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field DoublePrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.DOUBLE)
				}

				if cpb.StringPrimitive == "" {
					return nil, fmt.Errorf("expression for field StringPrimitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.StringPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field StringPrimitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field StringPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				if cpb.AnotherValueType == "" {
					return nil, fmt.Errorf("expression for field AnotherValueType cannot be empty")
				}
				if infrdType.AnotherValueType, err = tEvalFn(cpb.AnotherValueType); err != nil {
					return nil, err
				}

				for _, v := range cpb.DimensionsFixedInt64ValueDType {
					if t, e := tEvalFn(v); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field DimensionsFixedInt64ValueDType: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field DimensionsFixedInt64ValueDType: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
					}
				}

				_ = cpb
				return infrdType, err
			},
			ConfigureType: func(types map[string]proto.Message, builder *adapter.HandlerBuilder) error {
				// Mixer framework should have ensured the type safety.
				castedBuilder := (*builder).(istio_mixer_template_quota.HandlerBuilder)
				castedTypes := make(map[string]*istio_mixer_template_quota.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*istio_mixer_template_quota.Type)
					castedTypes[k] = v1
				}
				return castedBuilder.ConfigureQuotaHandler(castedTypes)
			},
			Evaluate: func(instName string, inst proto.Message, attrs attribute.Bag, mapper expr.Evaluator) (interface{}, error) {
				castedInst := inst.(*istio_mixer_template_quota.InstanceParam)

				Value, err := mapper.Eval(castedInst.Value, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval Value for instance '%s': %v", instName, err)
				}

				Dimensions, err := template.EvalAll(castedInst.Dimensions, attrs, mapper)

				if err != nil {
					return nil, fmt.Errorf("failed to eval Dimensions for instance '%s': %v", instName, err)
				}

				Int64Primitive, err := mapper.Eval(castedInst.Int64Primitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval Int64Primitive for instance '%s': %v", instName, err)
				}

				BoolPrimitive, err := mapper.Eval(castedInst.BoolPrimitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval BoolPrimitive for instance '%s': %v", instName, err)
				}

				DoublePrimitive, err := mapper.Eval(castedInst.DoublePrimitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval DoublePrimitive for instance '%s': %v", instName, err)
				}

				StringPrimitive, err := mapper.Eval(castedInst.StringPrimitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval StringPrimitive for instance '%s': %v", instName, err)
				}

				AnotherValueType, err := mapper.Eval(castedInst.AnotherValueType, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval AnotherValueType for instance '%s': %v", instName, err)
				}

				DimensionsFixedInt64ValueDType, err := template.EvalAll(castedInst.DimensionsFixedInt64ValueDType, attrs, mapper)

				if err != nil {
					return nil, fmt.Errorf("failed to eval DimensionsFixedInt64ValueDType for instance '%s': %v", instName, err)
				}

				_ = castedInst

				return &istio_mixer_template_quota.Instance{
					Name: instName,

					Value: Value,

					Dimensions: Dimensions,

					Int64Primitive: Int64Primitive.(int64),

					BoolPrimitive: BoolPrimitive.(bool),

					DoublePrimitive: DoublePrimitive.(float64),

					StringPrimitive: StringPrimitive.(string),

					AnotherValueType: AnotherValueType,

					DimensionsFixedInt64ValueDType: func(m map[string]interface{}) map[string]int64 {
						res := make(map[string]int64, len(m))
						for k, v := range m {
							res[k] = v.(int64)
						}
						return res
					}(DimensionsFixedInt64ValueDType),
				}, nil
			},

			DispatchReport: func(ctx context.Context, insts interface{}, handler adapter.Handler) (adapter.ReportResult, error) {
				return handler.(istio_mixer_template_quota.Handler).HandleQuota(ctx, insts.([]*istio_mixer_template_quota.Instance))
			},
			DispatchCheck: nil,
			DispatchQuota: nil,
		},

		istio_mixer_template_log.TemplateName: {
			CtrCfg:             &istio_mixer_template_log.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  "istio.io/mixer/template/log.HandlerBuilder",
			HndlrInterfaceName: "istio.io/mixer/template/log.Handler",
			SupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(istio_mixer_template_log.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(istio_mixer_template_log.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {
				var err error = nil
				cpb := cp.(*istio_mixer_template_log.InstanceParam)
				infrdType := &istio_mixer_template_log.Type{}

				if cpb.Value == "" {
					return nil, fmt.Errorf("expression for field Value cannot be empty")
				}
				if infrdType.Value, err = tEvalFn(cpb.Value); err != nil {
					return nil, err
				}

				infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
				for k, v := range cpb.Dimensions {
					if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
						return nil, err
					}
				}

				if cpb.Int64Primitive == "" {
					return nil, fmt.Errorf("expression for field Int64Primitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.Int64Primitive); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field Int64Primitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field Int64Primitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
				}

				if cpb.BoolPrimitive == "" {
					return nil, fmt.Errorf("expression for field BoolPrimitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.BoolPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.BOOL {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field BoolPrimitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field BoolPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.BOOL)
				}

				if cpb.DoublePrimitive == "" {
					return nil, fmt.Errorf("expression for field DoublePrimitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.DoublePrimitive); e != nil || t != istio_mixer_v1_config_descriptor.DOUBLE {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field DoublePrimitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field DoublePrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.DOUBLE)
				}

				if cpb.StringPrimitive == "" {
					return nil, fmt.Errorf("expression for field StringPrimitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.StringPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field StringPrimitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field StringPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				if cpb.AnotherValueType == "" {
					return nil, fmt.Errorf("expression for field AnotherValueType cannot be empty")
				}
				if infrdType.AnotherValueType, err = tEvalFn(cpb.AnotherValueType); err != nil {
					return nil, err
				}

				for _, v := range cpb.DimensionsFixedInt64ValueDType {
					if t, e := tEvalFn(v); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field DimensionsFixedInt64ValueDType: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field DimensionsFixedInt64ValueDType: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
					}
				}

				_ = cpb
				return infrdType, err
			},
			ConfigureType: func(types map[string]proto.Message, builder *adapter.HandlerBuilder) error {
				// Mixer framework should have ensured the type safety.
				castedBuilder := (*builder).(istio_mixer_template_log.HandlerBuilder)
				castedTypes := make(map[string]*istio_mixer_template_log.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*istio_mixer_template_log.Type)
					castedTypes[k] = v1
				}
				return castedBuilder.ConfigureLogHandler(castedTypes)
			},
			Evaluate: func(instName string, inst proto.Message, attrs attribute.Bag, mapper expr.Evaluator) (interface{}, error) {
				castedInst := inst.(*istio_mixer_template_log.InstanceParam)

				Value, err := mapper.Eval(castedInst.Value, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval Value for instance '%s': %v", instName, err)
				}

				Dimensions, err := template.EvalAll(castedInst.Dimensions, attrs, mapper)

				if err != nil {
					return nil, fmt.Errorf("failed to eval Dimensions for instance '%s': %v", instName, err)
				}

				Int64Primitive, err := mapper.Eval(castedInst.Int64Primitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval Int64Primitive for instance '%s': %v", instName, err)
				}

				BoolPrimitive, err := mapper.Eval(castedInst.BoolPrimitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval BoolPrimitive for instance '%s': %v", instName, err)
				}

				DoublePrimitive, err := mapper.Eval(castedInst.DoublePrimitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval DoublePrimitive for instance '%s': %v", instName, err)
				}

				StringPrimitive, err := mapper.Eval(castedInst.StringPrimitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval StringPrimitive for instance '%s': %v", instName, err)
				}

				AnotherValueType, err := mapper.Eval(castedInst.AnotherValueType, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval AnotherValueType for instance '%s': %v", instName, err)
				}

				DimensionsFixedInt64ValueDType, err := template.EvalAll(castedInst.DimensionsFixedInt64ValueDType, attrs, mapper)

				if err != nil {
					return nil, fmt.Errorf("failed to eval DimensionsFixedInt64ValueDType for instance '%s': %v", instName, err)
				}

				_ = castedInst

				return &istio_mixer_template_log.Instance{
					Name: instName,

					Value: Value,

					Dimensions: Dimensions,

					Int64Primitive: Int64Primitive.(int64),

					BoolPrimitive: BoolPrimitive.(bool),

					DoublePrimitive: DoublePrimitive.(float64),

					StringPrimitive: StringPrimitive.(string),

					AnotherValueType: AnotherValueType,

					DimensionsFixedInt64ValueDType: func(m map[string]interface{}) map[string]int64 {
						res := make(map[string]int64, len(m))
						for k, v := range m {
							res[k] = v.(int64)
						}
						return res
					}(DimensionsFixedInt64ValueDType),
				}, nil
			},

			DispatchReport: func(ctx context.Context, insts interface{}, handler adapter.Handler) (adapter.ReportResult, error) {
				return handler.(istio_mixer_template_log.Handler).HandleLog(ctx, insts.([]*istio_mixer_template_log.Instance))
			},
			DispatchCheck: nil,
			DispatchQuota: nil,
		},

		istio_mixer_template_metric.TemplateName: {
			CtrCfg:             &istio_mixer_template_metric.InstanceParam{},
			Variety:            adptTmpl.TEMPLATE_VARIETY_REPORT,
			BldrInterfaceName:  "istio.io/mixer/template/metric.HandlerBuilder",
			HndlrInterfaceName: "istio.io/mixer/template/metric.Handler",
			SupportsTemplate: func(hndlrBuilder adapter.HandlerBuilder) bool {
				_, ok := hndlrBuilder.(istio_mixer_template_metric.HandlerBuilder)
				return ok
			},
			HandlerSupportsTemplate: func(hndlr adapter.Handler) bool {
				_, ok := hndlr.(istio_mixer_template_metric.Handler)
				return ok
			},
			InferType: func(cp proto.Message, tEvalFn template.TypeEvalFn) (proto.Message, error) {
				var err error = nil
				cpb := cp.(*istio_mixer_template_metric.InstanceParam)
				infrdType := &istio_mixer_template_metric.Type{}

				if cpb.Value == "" {
					return nil, fmt.Errorf("expression for field Value cannot be empty")
				}
				if infrdType.Value, err = tEvalFn(cpb.Value); err != nil {
					return nil, err
				}

				infrdType.Dimensions = make(map[string]istio_mixer_v1_config_descriptor.ValueType, len(cpb.Dimensions))
				for k, v := range cpb.Dimensions {
					if infrdType.Dimensions[k], err = tEvalFn(v); err != nil {
						return nil, err
					}
				}

				if cpb.Int64Primitive == "" {
					return nil, fmt.Errorf("expression for field Int64Primitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.Int64Primitive); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field Int64Primitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field Int64Primitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
				}

				if cpb.BoolPrimitive == "" {
					return nil, fmt.Errorf("expression for field BoolPrimitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.BoolPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.BOOL {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field BoolPrimitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field BoolPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.BOOL)
				}

				if cpb.DoublePrimitive == "" {
					return nil, fmt.Errorf("expression for field DoublePrimitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.DoublePrimitive); e != nil || t != istio_mixer_v1_config_descriptor.DOUBLE {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field DoublePrimitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field DoublePrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.DOUBLE)
				}

				if cpb.StringPrimitive == "" {
					return nil, fmt.Errorf("expression for field StringPrimitive cannot be empty")
				}
				if t, e := tEvalFn(cpb.StringPrimitive); e != nil || t != istio_mixer_v1_config_descriptor.STRING {
					if e != nil {
						return nil, fmt.Errorf("failed to evaluate expression for field StringPrimitive: %v", e)
					}
					return nil, fmt.Errorf("error type checking for field StringPrimitive: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.STRING)
				}

				if cpb.AnotherValueType == "" {
					return nil, fmt.Errorf("expression for field AnotherValueType cannot be empty")
				}
				if infrdType.AnotherValueType, err = tEvalFn(cpb.AnotherValueType); err != nil {
					return nil, err
				}

				for _, v := range cpb.DimensionsFixedInt64ValueDType {
					if t, e := tEvalFn(v); e != nil || t != istio_mixer_v1_config_descriptor.INT64 {
						if e != nil {
							return nil, fmt.Errorf("failed to evaluate expression for field DimensionsFixedInt64ValueDType: %v", e)
						}
						return nil, fmt.Errorf("error type checking for field DimensionsFixedInt64ValueDType: Evaluated expression type %v want %v", t, istio_mixer_v1_config_descriptor.INT64)
					}
				}

				_ = cpb
				return infrdType, err
			},
			ConfigureType: func(types map[string]proto.Message, builder *adapter.HandlerBuilder) error {
				// Mixer framework should have ensured the type safety.
				castedBuilder := (*builder).(istio_mixer_template_metric.HandlerBuilder)
				castedTypes := make(map[string]*istio_mixer_template_metric.Type, len(types))
				for k, v := range types {
					// Mixer framework should have ensured the type safety.
					v1 := v.(*istio_mixer_template_metric.Type)
					castedTypes[k] = v1
				}
				return castedBuilder.ConfigureMetricHandler(castedTypes)
			},
			Evaluate: func(instName string, inst proto.Message, attrs attribute.Bag, mapper expr.Evaluator) (interface{}, error) {
				castedInst := inst.(*istio_mixer_template_metric.InstanceParam)

				Value, err := mapper.Eval(castedInst.Value, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval Value for instance '%s': %v", instName, err)
				}

				Dimensions, err := template.EvalAll(castedInst.Dimensions, attrs, mapper)

				if err != nil {
					return nil, fmt.Errorf("failed to eval Dimensions for instance '%s': %v", instName, err)
				}

				Int64Primitive, err := mapper.Eval(castedInst.Int64Primitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval Int64Primitive for instance '%s': %v", instName, err)
				}

				BoolPrimitive, err := mapper.Eval(castedInst.BoolPrimitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval BoolPrimitive for instance '%s': %v", instName, err)
				}

				DoublePrimitive, err := mapper.Eval(castedInst.DoublePrimitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval DoublePrimitive for instance '%s': %v", instName, err)
				}

				StringPrimitive, err := mapper.Eval(castedInst.StringPrimitive, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval StringPrimitive for instance '%s': %v", instName, err)
				}

				AnotherValueType, err := mapper.Eval(castedInst.AnotherValueType, attrs)

				if err != nil {
					return nil, fmt.Errorf("failed to eval AnotherValueType for instance '%s': %v", instName, err)
				}

				DimensionsFixedInt64ValueDType, err := template.EvalAll(castedInst.DimensionsFixedInt64ValueDType, attrs, mapper)

				if err != nil {
					return nil, fmt.Errorf("failed to eval DimensionsFixedInt64ValueDType for instance '%s': %v", instName, err)
				}

				_ = castedInst

				return &istio_mixer_template_metric.Instance{
					Name: instName,

					Value: Value,

					Dimensions: Dimensions,

					Int64Primitive: Int64Primitive.(int64),

					BoolPrimitive: BoolPrimitive.(bool),

					DoublePrimitive: DoublePrimitive.(float64),

					StringPrimitive: StringPrimitive.(string),

					AnotherValueType: AnotherValueType,

					DimensionsFixedInt64ValueDType: func(m map[string]interface{}) map[string]int64 {
						res := make(map[string]int64, len(m))
						for k, v := range m {
							res[k] = v.(int64)
						}
						return res
					}(DimensionsFixedInt64ValueDType),
				}, nil
			},

			DispatchReport: func(ctx context.Context, insts interface{}, handler adapter.Handler) (adapter.ReportResult, error) {
				return handler.(istio_mixer_template_metric.Handler).HandleMetric(ctx, insts.([]*istio_mixer_template_metric.Instance))
			},
			DispatchCheck: nil,
			DispatchQuota: nil,
		},
	}
)
