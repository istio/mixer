# Design Proposal: Monitoring the Istio Service Mesh

Status: **DRAFT**

- [Introduction](#Introduction)
- [Proposed Design](#Proposed_Design)
  - [Design Summary](#Design_Summary)
  - [Telemetry Generation And Reporting](#Telemetry_Generation_And_Reporting)
    - [Schema Publishing](#Schema_Publishing)
    - [Example Library Pseudocode](#Example_Library_Pseudocode)
  - [Mixer-Specific Telemetry](#Mixer-Specific_Telemetry)

## Introduction

The [Istio Service Mesh](http://github.com/istio/istio) provides automated 
telemetry data collection for integrated services. As requests flow through the
service mesh, request metadata is generated by the [Proxy](http://github.com/istio/proxy) 
and sent to the [Mixer](http://github.com/istio/mixer). The Mixer repackages the
received metadata, generating access logs and request metrics, and transmits the
telemetry data to a configurable set of backend systems for monitoring and 
alerting.

Istio development has, so far, focused on providing the subsystems for the 
reporting of telemetry data and for tailoring the collection to match the intent
of the service operators. Little attention has been devoted to monitoring the 
behavior of the individual Istio components (Proxy, [Manager](http://github.com/istio/manager),
Mixer).

This document proposes a high-level design for the monitoring of the Istio 
Service Mesh itself.

## Proposed Design

The proposed design adopts two high-level goals:
1. **Limit special handling for Istio components**
   - Telemetry data for the Istio Proxy and Istio Manager components _should_ be
     reported via the mixer through the same mechanisms as telemetry data for 
     the non-Istio services within the service mesh.
   - Telemetry data for the Istio Mixer itself _should_ be sent through the same 
     processing code as data received via RPCs.
1. **Prevent mixer-generated traffic from generating additional reports**
   - In order to prevent a never-ending loop of reporting of metrics, traffic
     generated by mixer to downstream services (e.g. logging/metrics backends)
     _must_ be exempted from triggering the push of new telemetry data to 
     backend systems.

### Design Summary

Each Istio component will be responsible for the following:
1. Generating its own set of telemetry data (logs/metrics)
1. Reporting that data to the Istio Mixer, on a regular basis, via the existing
   Mixer API (see: [ReportRequest](https://github.com/istio/api/blob/master/mixer/v1/report.proto#L23)).
1. Publishing the set of schemas for the telemetry data generated by its 
   component in a *discoverable* fashion.

In order to prevent a never-ending loop of Reports, Mixer will be configured to
drop ReportRequests received where the source of the traffic being reported is
Mixer itself.

### Telemetry Generation and Reporting

Schemas for telemetry data are necessary for Mixer to properly convert 
ReportRequests into logs and metrics for various backend systems (see: 
[LogEntryDescriptor](https://github.com/istio/api/blob/master/mixer/v1/config/descriptor/log_entry_descriptor.proto#L22),
[MetricsDescriptor](https://github.com/istio/api/blob/master/mixer/v1/config/descriptor/metric_descriptor.proto#L53)).

It would be extremely onerous to require that these schemas be kept in sync with
an external configuration file (and that developers update those configs when, 
for example, introducing new monitoring metrics in their code).

To address this concern, a set of libraries will be built for use within each 
component that will provide easy declaration of metrics and logs for use in line
with code. These libraries will also provide publishing utilities for both the
schemas (and their associated attribute expressions) and the values themselves.

The monitoring libraries will enable a user to:
- Declare new metrics in a simple, idiomatic fashion
- Collect and report on both the full set of metrics and their schema
- Generate and transmit a full set of ReportRequests to Mixer (with the option
  for establishing a configurable periodic report).

It is expected that non-Istio services may also want to use these libraries 
eventually. As a result these libraries will be developed so as to be separable
and reusable.

#### Schema Publishing

**TBD**: Protocol/scheme for publishing _schemas_ to Mixer (and/or
global config space).

#### Example Library Pseudocode

Golang pseudocode for how Istio components (as well as third-party
services) might use the developed libraries to instrument their own code:

```go

var (
	numFoos = monitoring.NewCounter(
		"mixer/foo_count",                  // metric name (should be unique)
		"Mixer Foos",                       // display name
		"Number of foos observed by Mixer", // description
		labels.Bool("bar"),
		labels.String("baz"),
	)
	...
)

func generateFoo() {
	numFoos.Add(1, true, "baz")
	...
}

func publish(ctx context.Context, endpoint string) {
	...
	monitoring.NewClient(endpoint).Report(ctx)
	...
}
```

### Mixer-Specific Telemetry

Mixer will track, via instrumented aspect manager and adapter code, the
traffic that it generates, maintaining proper monitoring of backend error
rates and latencies, etc. As with the other Istio components, Mixer will 
periodically push its set of tracked metrics and logs to the configured
backends. Instead of generating full-fledged `Report()` RPCs, Mixer will pipe 
the reports directly into the appropriate RPC handling code.

To detect the Report traffic Istio generates in response to Mixer sending 
telemetry data to various backend services and avoid a Report loop, Mixer will 
rely on the attribute `source.uid` in `ReportRequest`s. When 
`source.uid == ${mixer_uid}`, the Report will be dropped (generating no further
traffic).

**TBD**: Should Mixer provide separate handling for this data instead of
dropping it? It might make things a bit more complex, but they could be shunted
off to a special set of mixer metric adapters that simply record the data, but
schedule it for periodic delivery.

## References

- [istio/mixer#63](https://github.com/istio/mixer/issues/63) is the tracking
  bug for discussion of this issue.